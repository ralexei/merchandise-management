<#@ template language="C#" hostspecific="true" debug="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ assembly name="System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ assembly name="System.Xml.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Resources" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Xml.Linq" #>
<#
    
    string directory = Path.Combine(System.IO.Path.GetDirectoryName(this.Host.TemplateFile), "Resources");
    const string fileName = "variables.less";
    string variablesPaths = Path.Combine(directory, fileName);
    
    const string variablePrefix = "@fa-var-";
    
    const string visibility = "public";
    string namespaceHint = (string)System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint");
    string @namespace = namespaceHint ?? "FontAwesome";
    
    const bool generateEnum = true;
    const bool generateConstants = true;
    const bool generateDictionary = false;
    const bool generateWpfExtensions = true;

    // Enumerate font variable
    List<NameValue> pairs = new List<NameValue>();
    using (StreamReader reader = new StreamReader(variablesPaths))
    {
        string line;
        while((line = reader.ReadLine()) != null)
        {
            // @fa-var-adjust: "\f042";
            if(!line.StartsWith(variablePrefix))
                continue;

            int valueIndex = line.IndexOf(':');
            if (valueIndex < 0)
                continue;
                        
            string variableName = line.Substring(variablePrefix.Length, valueIndex - variablePrefix.Length).Trim();
            string value = line.Substring(valueIndex + 1);
            int valueStartIndex = value.IndexOf('"');
            if (valueStartIndex < 0)
                continue;

            int valueEndIndex = value.IndexOf('"', valueStartIndex + 1);
            if (valueEndIndex < 0)
                continue;

            value = value.Substring(valueStartIndex + 2, valueEndIndex - valueStartIndex - 2);
            pairs.Add(new NameValue(variableName, value));
        }
    } 

#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:<#= Environment.Version #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace <#= @namespace #> 
{
<#
	if(generateWpfExtensions)
	{
#>
	using System;
	using System.Collections.Generic;
	using System.Reflection;
	using System.Text;
	using System.Windows.Markup;	

<#
	}

	if(generateEnum)
	{
#>
    /// <summary>
    /// Font Awesome Icons.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("<#= GetType().ToString() #>", "1.0.0.0")]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    <#= visibility #> enum FontAwesomeIconEnum
    {
<#
		foreach(NameValue pair in pairs)
		{
#>

        /// <summary>
        /// fa-<#= pair.Name #> icon (<#= pair.Value #>)
        /// </summary>
        <#= CamelName(pair.Name) #> = 0x<#= pair.Value #>,
<#		
		} 
	}
#>
    }

    /// <summary>
    /// Font Awesome Icons.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("<#= GetType().ToString() #>", "1.0.0.0")]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    <#= visibility #> static partial class FontAwesomeIcons
    {
<#
	if (generateConstants)
	{
	    foreach (NameValue pair in pairs)
	    {
#>

        /// <summary>
        /// fa-<#= pair.Name #> icon (<#= pair.Value #>)
        /// </summary>
        public const string <#= CamelName(pair.Name) #> = "\u<#= pair.Value #>";
<#
	    }
	}

	if(generateDictionary)
	{
#>
		private static IDictionary<string, string> _allIcons;
        
		public static IDictionary<string, string> AllIcons
        {
            get { return _allIcons; }
        }

        static FontAwesomeIcons()
        {
            _allIcons = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
<#
	HashSet<string> strings = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
	foreach(NameValue pair in pairs)
    {
		if(!strings.Contains(pair.Name))
		{
			strings.Add(pair.Name);
#>
            _allIcons.Add("<#= pair.Name #>", "\u<#= pair.Value #>");
<#
		}
		if(!strings.Contains(CamelName(pair.Name)))
		{
			strings.Add(CamelName(pair.Name));
#>
            _allIcons.Add("<#= CamelName(pair.Name) #>", "\u<#= pair.Value #>");
<#		
		}
    } 
#>
		}

<# 
	}
#>
    }
<#
    if (generateWpfExtensions)
    {
#>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("<#= GetType().ToString() #>", "1.0.0.0")]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [MarkupExtensionReturnType(typeof(string))]
    <#= visibility #> partial class IconExtension : MarkupExtension
    {
        public IconExtension()
        {
        }
        
        public IconExtension(FontAwesomeIconEnum icon)
        {
            Icon = icon;
        }
        
        [ConstructorArgument("icon")]
        public FontAwesomeIconEnum Icon { get; set; }

        public override object ProvideValue(IServiceProvider serviceProvider)
        {
            return ((char)Icon).ToString();
        }
	}
<#
    }
#>
}
<#+

    class NameValue
    {
        public NameValue(string name, string value)
        {
            Name = name;
            Value = value;
        }

        public string Name { get; set; }
        public string Value { get; set; }
    }

    string CamelName(string name)
    {
        StringBuilder sb = new StringBuilder();
        bool upperCase = true;
        foreach(char c in name)
        {
            if(c == '-')
            {
                upperCase = true;
                continue;
            }

            if(upperCase)
            {
                sb.Append(char.ToUpper(c));
            }
            else
            {
                sb.Append(c);
            }

            upperCase = false;
        }
        
        return sb.ToString();
    }

#>